/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import * as errors from "../models/errors";
import * as operations from "../models/operations";

export enum ExportDatasetAcceptEnum {
    applicationJson = "application/json",
    applicationLdPlusJson = "application/ld+json",
    applicationHtml = "application/html",
    applicationXml = "application/xml",
}

export class Native extends ClientSDK {
    private readonly options$: SDKOptions;

    constructor(options: SDKOptions = {}) {
        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
        });

        this.options$ = options;
        void this.options$;
    }
    async exportDataset(
        persistentId?: string | undefined,
        exporter?: string | undefined,
        options?: RequestOptions & { acceptHeaderOverride?: ExportDatasetAcceptEnum }
    ): Promise<operations.ExportDatasetResponse> {
        const input$: operations.ExportDatasetRequest = {
            persistentId: persistentId,
            exporter: exporter,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept =
            options?.acceptHeaderOverride ||
            "application/json;q=1, application/ld+json;q=0.8, application/html;q=0.5, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = operations.ExportDatasetRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/api/v1/datasets/export")();

        const query$ = [
            enc$.encodeForm("exporter", payload$.exporter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("persistentId", payload$.persistentId, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "application/html")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.ExportDatasetResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else if (this.matchResponse(response, "default", "application/xml")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.ExportDatasetResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else if (this.matchResponse(response, "default", "application/json")) {
            const responseBody = await response.json();
            const result = operations.ExportDatasetResponse$.inboundSchema.parse({
                ...responseFields$,
                "default_application/json_object": responseBody,
            });
            return result;
        } else if (this.matchResponse(response, "default", "application/ld+json")) {
            const responseBody = await response.json();
            const result = operations.ExportDatasetResponse$.inboundSchema.parse({
                ...responseFields$,
                "default_application/ld+json_object": responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async getAssignments(
        identifier: string,
        options?: RequestOptions
    ): Promise<operations.GetAssignmentsResponse> {
        const input$: operations.GetAssignmentsRequest = {
            identifier: identifier,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.GetAssignmentsRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{identifier}/assignments")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.GetAssignmentsResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async createAssignment(
        identifier: string,
        key?: string | undefined,
        requestBody?: Uint8Array | string | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateAssignmentResponse> {
        const input$: operations.CreateAssignmentRequest = {
            identifier: identifier,
            key: key,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "*/*");
        headers$.set("Accept", "*/*");

        const payload$ = operations.CreateAssignmentRequest$.outboundSchema.parse(input$);

        const body$ = payload$.RequestBody;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{identifier}/assignments")(
            pathParams$
        );

        const query$ = [
            enc$.encodeForm("key", payload$.key, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.CreateAssignmentResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async getDataset(id: string, options?: RequestOptions): Promise<operations.GetDatasetResponse> {
        const input$: operations.GetDatasetRequest = {
            id: id,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.GetDatasetRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{id}")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.GetDatasetResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async deleteDataset(
        id: string,
        options?: RequestOptions
    ): Promise<operations.DeleteDatasetResponse> {
        const input$: operations.DeleteDatasetRequest = {
            id: id,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.DeleteDatasetRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{id}")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.DeleteDatasetResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async getDatasetByPid(
        persistentId: string,
        options?: RequestOptions
    ): Promise<operations.GetDatasetByPidResponse> {
        const input$: operations.GetDatasetByPidRequest = {
            persistentId: persistentId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.GetDatasetByPidRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/api/v1/datasets/:persistentId")();

        const query$ = [
            enc$.encodeForm("persistentId", payload$.persistentId, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.GetDatasetByPidResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async addFileToDataset(
        id: string,
        requestBody?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.AddFileToDatasetResponse> {
        const input$: operations.AddFileToDatasetRequest = {
            id: id,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.AddFileToDatasetRequest$.outboundSchema.parse(input$);

        const body$ = payload$.RequestBody;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{id}/add")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.AddFileToDatasetResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async destroyDataset(
        id: string,
        options?: RequestOptions
    ): Promise<operations.DestroyDatasetResponse> {
        const input$: operations.DestroyDatasetRequest = {
            id: id,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.DestroyDatasetRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{id}/destroy")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.DestroyDatasetResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async editVersionMetadata(
        id: string,
        replace?: boolean | undefined,
        requestBody?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.EditVersionMetadataResponse> {
        const input$: operations.EditVersionMetadataRequest = {
            id: id,
            replace: replace,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "*/*");
        headers$.set("Accept", "*/*");

        const payload$ = operations.EditVersionMetadataRequest$.outboundSchema.parse(input$);

        const body$ = payload$.RequestBody;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{id}/editMetadata")(pathParams$);

        const query$ = [
            enc$.encodeForm("replace", payload$.replace, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.EditVersionMetadataResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async getPrivateUrlData(
        id: string,
        options?: RequestOptions
    ): Promise<operations.GetPrivateUrlDataResponse> {
        const input$: operations.GetPrivateUrlDataRequest = {
            id: id,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.GetPrivateUrlDataRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{id}/privateUrl")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.GetPrivateUrlDataResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async createPrivateUrl(
        id: string,
        anonymizedAccess?: boolean | undefined,
        options?: RequestOptions
    ): Promise<operations.CreatePrivateUrlResponse> {
        const input$: operations.CreatePrivateUrlRequest = {
            id: id,
            anonymizedAccess: anonymizedAccess,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.CreatePrivateUrlRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{id}/privateUrl")(pathParams$);

        const query$ = [
            enc$.encodeForm("anonymizedAccess", payload$.anonymizedAccess, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.CreatePrivateUrlResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async deletePrivateUrl(
        id: string,
        options?: RequestOptions
    ): Promise<operations.DeletePrivateUrlResponse> {
        const input$: operations.DeletePrivateUrlRequest = {
            id: id,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.DeletePrivateUrlRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{id}/privateUrl")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.DeletePrivateUrlResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async listVersions(
        id: string,
        options?: RequestOptions
    ): Promise<operations.ListVersionsResponse> {
        const input$: operations.ListVersionsRequest = {
            id: id,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.ListVersionsRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{id}/versions")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.ListVersionsResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async getVersion(
        id: string,
        versionId: string,
        options?: RequestOptions
    ): Promise<operations.GetVersionResponse> {
        const input$: operations.GetVersionRequest = {
            id: id,
            versionId: versionId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.GetVersionRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
            versionId: enc$.encodeSimple("versionId", payload$.versionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{id}/versions/{versionId}")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.GetVersionResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async updateDraftVersion(
        id: string,
        versionId: string,
        requestBody?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.UpdateDraftVersionResponse> {
        const input$: operations.UpdateDraftVersionRequest = {
            id: id,
            versionId: versionId,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "*/*");

        const payload$ = operations.UpdateDraftVersionRequest$.outboundSchema.parse(input$);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
            versionId: enc$.encodeSimple("versionId", payload$.versionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{id}/versions/{versionId}")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.UpdateDraftVersionResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async deleteDraftVersion(
        id: string,
        versionId: string,
        options?: RequestOptions
    ): Promise<operations.DeleteDraftVersionResponse> {
        const input$: operations.DeleteDraftVersionRequest = {
            id: id,
            versionId: versionId,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.DeleteDraftVersionRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
            versionId: enc$.encodeSimple("versionId", payload$.versionId, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/datasets/{id}/versions/{versionId}")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.DeleteDraftVersionResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async viewDataverse(
        identifier: string,
        options?: RequestOptions
    ): Promise<operations.ViewDataverseResponse> {
        const input$: operations.ViewDataverseRequest = {
            identifier: identifier,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.ViewDataverseRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/dataverses/{identifier}")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.ViewDataverseResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async addDataverse(
        identifier: string,
        requestBody?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.AddDataverseResponse> {
        const input$: operations.AddDataverseRequest = {
            identifier: identifier,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "*/*");
        headers$.set("Accept", "*/*");

        const payload$ = operations.AddDataverseRequest$.outboundSchema.parse(input$);

        const body$ = payload$.RequestBody;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/dataverses/{identifier}")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.AddDataverseResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async deleteDataverse(
        identifier: string,
        options?: RequestOptions
    ): Promise<operations.DeleteDataverseResponse> {
        const input$: operations.DeleteDataverseRequest = {
            identifier: identifier,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.DeleteDataverseRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/dataverses/{identifier}")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.DeleteDataverseResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async publishDataverse(
        identifier: string,
        options?: RequestOptions
    ): Promise<operations.PublishDataverseResponse> {
        const input$: operations.PublishDataverseRequest = {
            identifier: identifier,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.PublishDataverseRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/dataverses/{identifier}/actions/:publish")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.PublishDataverseResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async listContent(
        identifier: string,
        options?: RequestOptions
    ): Promise<operations.ListContentResponse> {
        const input$: operations.ListContentRequest = {
            identifier: identifier,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.ListContentRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/dataverses/{identifier}/contents")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.ListContentResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async importDataset(
        identifier: string,
        pid?: string | undefined,
        release?: string | undefined,
        requestBody?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.ImportDatasetResponse> {
        const input$: operations.ImportDatasetRequest = {
            identifier: identifier,
            pid: pid,
            release: release,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "*/*");
        headers$.set("Accept", "*/*");

        const payload$ = operations.ImportDatasetRequest$.outboundSchema.parse(input$);

        const body$ = payload$.RequestBody;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/dataverses/{identifier}/datasets/:import")(
            pathParams$
        );

        const query$ = [
            enc$.encodeForm("pid", payload$.pid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("release", payload$.release, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.ImportDatasetResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async listFacets(
        identifier: string,
        options?: RequestOptions
    ): Promise<operations.ListFacetsResponse> {
        const input$: operations.ListFacetsRequest = {
            identifier: identifier,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.ListFacetsRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/dataverses/{identifier}/facets")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.ListFacetsResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async setFacets(
        identifier: string,
        requestBody?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.SetFacetsResponse> {
        const input$: operations.SetFacetsRequest = {
            identifier: identifier,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "*/*");
        headers$.set("Accept", "application/json");

        const payload$ = operations.SetFacetsRequest$.outboundSchema.parse(input$);

        const body$ = payload$.RequestBody;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/dataverses/{identifier}/facets")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "application/json")) {
            const responseBody = await response.json();
            const result = operations.SetFacetsResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async listRoles(
        identifier: string,
        options?: RequestOptions
    ): Promise<operations.ListRolesResponse> {
        const input$: operations.ListRolesRequest = {
            identifier: identifier,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.ListRolesRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/dataverses/{identifier}/roles")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.ListRolesResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async createRole(
        identifier: string,
        requestBody?: Uint8Array | string | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateRoleResponse> {
        const input$: operations.CreateRoleRequest = {
            identifier: identifier,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "*/*");
        headers$.set("Accept", "*/*");

        const payload$ = operations.CreateRoleRequest$.outboundSchema.parse(input$);

        const body$ = payload$.RequestBody;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/dataverses/{identifier}/roles")(
            pathParams$
        );

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.CreateRoleResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async getFileData(
        id: string,
        options?: RequestOptions
    ): Promise<operations.GetFileDataResponse> {
        const input$: operations.GetFileDataRequest = {
            id: id,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.GetFileDataRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/files/{id}")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.GetFileDataResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async deleteFileInDataset(
        id: string,
        options?: RequestOptions
    ): Promise<operations.DeleteFileInDatasetResponse> {
        const input$: operations.DeleteFileInDatasetRequest = {
            id: id,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.DeleteFileInDatasetRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/files/{id}")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.DeleteFileInDatasetResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async updateFileMetadata(
        id: string,
        requestBody?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.UpdateFileMetadataResponse> {
        const input$: operations.UpdateFileMetadataRequest = {
            id: id,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "*/*");
        headers$.set("Accept", "*/*");

        const payload$ = operations.UpdateFileMetadataRequest$.outboundSchema.parse(input$);

        const body$ = payload$.RequestBody;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/files/{id}/metadata")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.UpdateFileMetadataResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async redetectDatafile(
        id: string,
        dryRun?: boolean | undefined,
        options?: RequestOptions
    ): Promise<operations.RedetectDatafileResponse> {
        const input$: operations.RedetectDatafileRequest = {
            id: id,
            dryRun: dryRun,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.RedetectDatafileRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/files/{id}/redetect")(pathParams$);

        const query$ = [
            enc$.encodeForm("dryRun", payload$.dryRun, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.RedetectDatafileResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async reingest(id: string, options?: RequestOptions): Promise<operations.ReingestResponse> {
        const input$: operations.ReingestRequest = {
            id: id,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.ReingestRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/files/{id}/reingest")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.ReingestResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async replaceFileInDataset(
        id: string,
        requestBody?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.ReplaceFileInDatasetResponse> {
        const input$: operations.ReplaceFileInDatasetRequest = {
            id: id,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.ReplaceFileInDatasetRequest$.outboundSchema.parse(input$);

        const body$ = payload$.RequestBody;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/files/{id}/replace")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.ReplaceFileInDatasetResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async restrictFileInDataset(
        id: string,
        requestBody?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.RestrictFileInDatasetResponse> {
        const input$: operations.RestrictFileInDatasetRequest = {
            id: id,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "*/*");
        headers$.set("Accept", "*/*");

        const payload$ = operations.RestrictFileInDatasetRequest$.outboundSchema.parse(input$);

        const body$ = payload$.RequestBody;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/files/{id}/restrict")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.RestrictFileInDatasetResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async uningestDatafile(
        id: string,
        options?: RequestOptions
    ): Promise<operations.UningestDatafileResponse> {
        const input$: operations.UningestDatafileRequest = {
            id: id,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.UningestDatafileRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/files/{id}/uningest")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.UningestDatafileResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async getTermsOfUse(options?: RequestOptions): Promise<operations.GetTermsOfUseResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const path$ = this.templateURLComponent("/api/v1/info/apiTermsOfUse")();

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.GetTermsOfUseResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async getServer(options?: RequestOptions): Promise<operations.GetServerResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const path$ = this.templateURLComponent("/api/v1/info/server")();

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.GetServerResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async getInfo(options?: RequestOptions): Promise<operations.GetInfoResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const path$ = this.templateURLComponent("/api/v1/info/version")();

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.GetInfoResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async list(options?: RequestOptions): Promise<operations.ListResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/api/v1/metadatablocks")();

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "application/json")) {
            const responseBody = await response.json();
            const result = operations.ListResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async getBlock(
        identifier: string,
        options?: RequestOptions
    ): Promise<operations.GetBlockResponse> {
        const input$: operations.GetBlockRequest = {
            identifier: identifier,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.GetBlockRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            identifier: enc$.encodeSimple("identifier", payload$.identifier, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/api/v1/metadatablocks/{identifier}")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetBlockResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async createNewRole(
        dvo?: string | undefined,
        requestBody?: Uint8Array | string | undefined,
        options?: RequestOptions
    ): Promise<operations.CreateNewRoleResponse> {
        const input$: operations.CreateNewRoleRequest = {
            dvo: dvo,
            requestBody: requestBody,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "*/*");
        headers$.set("Accept", "*/*");

        const payload$ = operations.CreateNewRoleRequest$.outboundSchema.parse(input$);

        const body$ = payload$.RequestBody;

        const path$ = this.templateURLComponent("/api/v1/roles")();

        const query$ = [
            enc$.encodeForm("dvo", payload$.dvo, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.CreateNewRoleResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async viewRole(id: string, options?: RequestOptions): Promise<operations.ViewRoleResponse> {
        const input$: operations.ViewRoleRequest = {
            id: id,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.ViewRoleRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/roles/{id}")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.ViewRoleResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async deleteRole(id: string, options?: RequestOptions): Promise<operations.DeleteRoleResponse> {
        const input$: operations.DeleteRoleRequest = {
            id: id,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.DeleteRoleRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };

        const path$ = this.templateURLComponent("/api/v1/roles/{id}")(pathParams$);

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.DeleteRoleResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async getAuthenticatedUserByToken(
        options?: RequestOptions
    ): Promise<operations.GetAuthenticatedUserByTokenResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const path$ = this.templateURLComponent("/api/v1/users/:me")();

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.GetAuthenticatedUserByTokenResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async getTokenExpirationDate(
        options?: RequestOptions
    ): Promise<operations.GetTokenExpirationDateResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const path$ = this.templateURLComponent("/api/v1/users/token")();

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.GetTokenExpirationDateResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async deleteToken(options?: RequestOptions): Promise<operations.DeleteTokenResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const path$ = this.templateURLComponent("/api/v1/users/token")();

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "DELETE", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.DeleteTokenResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async recreateToken(options?: RequestOptions): Promise<operations.RecreateTokenResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const path$ = this.templateURLComponent("/api/v1/users/token/recreate")();

        let security$;
        if (typeof this.options$.apiKeyAuth === "function") {
            security$ = { apiKeyAuth: await this.options$.apiKeyAuth() };
        } else if (this.options$.apiKeyAuth) {
            security$ = { apiKeyAuth: this.options$.apiKeyAuth };
        } else {
            security$ = {};
        }
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "POST", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, "default", "*/*")) {
            const responseBody = await response.arrayBuffer();
            const result = operations.RecreateTokenResponse$.inboundSchema.parse({
                ...responseFields$,
                Body: new Uint8Array(responseBody),
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }
}
